
SimStm
======

SimStm is a VHDL testbench designed to facilitate testing driven by
external stimulus files with a “.stm” extension. This testbench is
provided by Eccelerators GmbH and aims to simplify test script creation
by introducing the SimStm language. Eccelerators GmbH provides IDE
support for this language through Visual Studio Code and Eclipse by
SimStm plugins; visit `Eccelerators <https://eccelerators.com>`__. The
full power of SimStm is achieved together with the HxS tool of
Eccelerators GmbH since all necessary SimStm code for the HW/SW
interfaces is generated by HxS.

History and License
-------------------

The original VHDL testbench was coded by Ken Campbell; visit
`GitHub <https://github.com/sckoarn/VHDL-Test-Bench>`__. Therefore, the
SimStm repository is forked from this original. The complete VHDL source
code of the SimStm VHDL testbench is distributed under the same license
as the original. However, Eccelerators GmbH has substantially
repartitioned and changed the code. The original copyright notice has
been retained within all source files related to the original.

The IDE plugins are available for free on the Eccelerators GmbH web
page. They may also be available for free on the respective IDE
marketplaces once deployed. The source code of the SimStm language IDE
plugins is the property of Eccelerators GmbH and is closed source.

Focus
-----

It is common practice to use the file I/O features of VHDL for VHDL
testbenches. Typically, each developer creates their own format for
commands in an input stimuli text file, along with a unique file name
and extension. The command set is focused on the tasks currently being
solved.

The general advantage of this technique is that the VHDL code of the
testbench doesn’t need to be changed and recompiled for different
stimuli command sets. Different command set files can be presented to
the VHDL testbench, or command files can be interactively changed during
debugging.

While the advantage of not having to recompile the VHDL testbench has
decreased due to increased computer and tool performance, a major part
of the advantage remains valid for reusability and having a first
decoupled level of abstraction for stimuli above the VHDL code.

This is particularly applicable to CPUs attached or integrated into
components under development. For example, an IP such as an
I2C-controller with a HW/SW interface can be tested with the same
stimuli, whether attached to an AXI-bus in a SOC of the latest
generation or to a plain microcontroller bus connected via copper on a
PCB to an FPGA housing the I2C controller IP.

SimStm focuses on this purpose. It delivers a command set that is fixed
and suitable for all needs in this context. The command set is defined
by a domain-specific language that provides and controls all necessary
keywords and object references, called the SimStm language. The commands
are referred to as instructions.

The SimStm language is edited within respective IDE plugins for Eclipse
or Visual Studio Code editors, supplying state-of-the-art coding support
such as syntax highlighting, auto-completion, error detection, and more.

The user starts editing a ``top.stm`` file and as many ``child.stm``
files as needed. The latter are included by ``include`` instructions,
which may be nested. ``Child.stm`` files can be used in a library manner
for reuse.

The SimStm instructions are purposely very close to HW to avoid
debugging through too much overhead. All objects declared, such as
variables, constants, arrays, implicit labels, etc., are global within
one SimStm project. All objects representing values consider the values
to be unsigned 32-bit integer values.

Future development steps of SimStm may introduce larger unsigned integer
values, e.g., 64-bit, 128-bit, if specified in a new package to be
customized by the user. Other parameters may be opened to the user, such
as the maximum object ID string length, and others, once their
modification has been tested to work as expected. Further development
steps may introduce namespaces together with the abilities of the IDE
plugins.

The SimStm testbench presents a bus and a signal package source file to
the user. These packages can be customized by the user to add busses,
signals, or interrupts to the testbench. All other files shall be used
unchanged. Eccelerator samples for Wishbone, Avalon, and AXI4lite busses
for single read/write accesses are already included.

The primary focus of SimStm is to have a **functional** verification of
all connected IPs via multiple busses with high coverage in a short
time. It is **not** prepared to be used to verify the different
conditions and sequences of accesses to the busses like other
testbenches. However, it could control these testbenches via respective
bus adapters. Eccelerators uses its own HxS tool to design and generate
HW/SW interfaces. The patterns used by the generators are verified to
work with all circumstances happening on the supported busses all the
way to having counterparts in other asynchronous clock domains. The
generated instances do not have to be verified again at this depth.

The SimStm language can be transpiled into Python, C, and other
programming languages to use the code written in SimStm for a first test
of a target HW. Thus, a functional coverage test is achieved very fast
when the real target HW arrives. The transport and isolation of problems
from the real application to the simulation environment and vice versa
are simplified. Interaction between SW and HW developers is simplified
too since SW developers can work with SimStm code rather than VHDL.

Features and Advantages
-----------------------

-  Compact and lightweight
-  Pure VHDL 2008, no use of a vendor-specific simulator interface
-  Easy to debug within any simulator, instructions close to HW
-  Abstraction of test code by SimStm language
-  State-of-the-art SimStm language IDE support for rapid test case
   creation
-  Test case code change and test without recompilation
-  SimStm language transpiles to Python or C, thus simulation code can
   be reused for the test of real target HW
-  Easily customizable to support user-defined busses, signals, and
   interrupts
-  Standard busses Axi4Lite, Avalon, and Wishbone are included

Installation and Usage of the Plugins
-------------------------------------

Visual Studio Code
~~~~~~~~~~~~~~~~~~

-  Open Visual Studio Code.
-  Go to the Extensions Marketplace.
-  Search for “SimStm” and install the plugin.
-  Create or open a “.stm” test script file.
-  Leverage the plugin’s IDE features to enhance your testing workflow.

Eclipse
~~~~~~~

-  Navigate to `Eccelerators <https://eccelerators.com>`__.
-  Download the “SimStm” Eclipse plugin.
-  Unpack it to a local folder.
-  Open Eclipse and navigate via the menu to “Help”, “Install new
   Software…”
-  Press the “Add” button.
-  Choose “Local”, enter SimStm as the plugin name.
-  Browse to the folder you have unpacked as the location.
-  Press the “Install” button.
-  Create or open a “.stm” test script file within a project.
-  Leverage the plugin’s IDE features to enhance your testing workflow.

Overview and Integration into User Testbench
--------------------------------------------

The following picture illustrates how the ``tb_simstm`` module is
integrated into the user testbench. The ``tb_simstm`` module should not
be changed by the user. The signals and interrupts that the user wants
to control the DUT or the Mocks shall be defined in ``tb_signals_pkg``.
The buses the user wants to connect to the DUT or the Mocks shall be
defined in ``tb_bus_pkg``, and eventually, a new bus type package if the
predefined buses aren’t sufficient. All other packages shall not be
changed.

.. figure:: https://github.com/eccelerators/simstm/assets/124497409/1f15e6b8-1587-4bd7-96a7-8ad51ebe7d05
   :alt: simstm-overview

   simstm-overview

Contributions and Bugs
----------------------

Eccelerators accepts GitHub pull requests, GitHub issues, or an email to
trigger a bug fix. Reported issues with samples cut down to reproduce a
bug are highly appreciated. In the case of email, please send it to
``support@eccelerators.com``.

Eccelerators may accept pull requests for small improvements.

SimStm language instructions
----------------------------

General
~~~~~~~

In SimStm instructions a line is a instruction, except empty lines or
comment only lines. Subroutine labels are considered as instruction in
this manner too.

The colon postfix of a subroutine label must end with a colon. No space
is allowed between the label ID and the colon. A dollar sign as prefix
is used to reference to object content e.g. variables. No space is
allowed between the dollar sign and referenced object ID. Otherwise the
SimStm language is not white space sensitive.

The SimStm language is case sensitive.

All constant, variable or label ID are global within a SimStm project.
The IDs must be unique.

There are no subroutine parameters or local variables. Values must be
passed by unique global objects. This is an accommodation to having a
simple SimStm interpreter and develops its own charm when using and
debugging it.

The subroutine with the label ``Main:``\ is the entry point into the
SimStm code for the simulator.

Comments
~~~~~~~~

.. code-block:: none

 -- This is a full line comment*
 const aconst 0x03 -- This is an appended line comment

| Comments in a line start with two hyphens.
| There are only line comments but no block comments.

Includes, Language Objects, and Declarations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Include
^^^^^^^

.. code-block:: none

 include "aninclude.stm"
   
Include another child ``\*.stm file``.

Include instructions should be the first instructions of a ``\*.stm file``.
An included file can include further ``\*.stm files``, thus nested includes
are possible. The file path to be given is relative to the file with the
respective include instruction. Nested includes of files from the same
folder or in child folders are predictable; nested includes to files in
parent folders would be bad practice.

Const
^^^^^

.. code-block:: none

 const aconst 0x03
 const bconst 0b011
 const cconst 3

| Declare and define a constant with ID and hex, binary, or decimal
  unsigned 32-bit integer value.
| It isn’t possible to initialize a constant by referencing another
  constant or variable.

Var
^^^

.. code-block:: none

 var avar 0x03
 var bvar 0b011
 var cvar 3

| Declare and define a variable with ID and initial hex, binary, or
  decimal unsigned 32-bit integer value.
| It isn’t possible to initialize a variable by referencing another
  variable or constant yet. The ``equ``
  instruction must be used within a procedure for this purpose.

Array
^^^^^

.. code-block:: none

 var barray 16

| Declare an array with ID and an unsigned 32-bit integer length.
| Only arrays with one dimension are possible; the length must be fixed.

File
^^^^

.. code-block:: none

 file afile "filename.stm"
 file afile "filename{:d}{:d}.stm"} $index1 $index2

Declare a file with ID and file name.

The latter must be a relative path to the location of the main.stm file.
Text substitution by variables is allowed in file names. Thus, files can
be accessed in an indexed manner. The variables are evaluated each time
when a reference to a file is used in another instruction accessing a
file, e.g., ``file read all afile alines``.

Lines
^^^^^

.. code-block:: none

 lines alines

| Declare a lines object with ID.
| The lines object contains an arbitrary number of line objects. It is
  defined to have no content when it is declared by default. It can grow
  or shrink dynamically by lines instructions accessing it, e.g.,
  ``lines insert array alines 9 barray``.

Signal
^^^^^^

.. code-block:: none

 signal asignal

Declare a signal object with ID.

The signal object associates a SimStm signal name with a signal number.
This signal number must be given in the tb_signal package by
customization and attached to a signal.

Bus
^^^

.. code-block:: none

 bus abus

Declare a bus object with ID.

The signal object associates a SimStm bus name with a bus number. This
bus number must be given in the tb_bus package by customization and
attached to a bus.

Equations and Arithmetic Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

equ
^^^

.. code-block:: none

 equ operand1 $operand2
 equ operand1 0xF0

Copy the value of operand2 variable, constant, or numeric value into
variable operand1 value or copy the value 0xF0 into variable operand1
value.

add
^^^

.. code-block:: none

 add operand1 $operand2
 add operand1 0xF0

Add variable or constant operand2 value to variable operand1 value or
add value 0xF0 to variable operand1 value. The resulting value of the
addition is in variable operand1 value after the operation.

sub
^^^

.. code-block:: none

 sub operand1 $operand2
 sub operand1 0xF0`

Subtract variable or constant operand2 value from variable operand1
value or subtract value 0xF0 from variable operand1 value. The resulting
value of the subtraction is in variable operand1 value after the
operation.

mul
^^^

.. code-block:: none

 mul operand1 $operand2
 mul operand1 0xF0

Multiply variable or constant operand2 value with variable operand1
value or multiply value 0xF0 with variable operand1 value. The resulting
value of the multiplication is in variable operand1 value after the
operation.

div
^^^

.. code-block:: none

 div operand1 $operand2
 div operand1 0xF0

Divide variable operand1 value by variable or constant operand2 value or
divide variable operand1 value by value 0xF0. The resulting value of the
division is in variable operand1 value after the operation.

and
^^^

.. code-block:: none

 and operand1 $operand2
 and operand1 0xF0

Bitwise and variable or constant operand2 value with variable operand1
value or bitwise and value 0xF0 with variable operand1 value. The
resulting value of the bitwise and is in variable operand1 value after
the operation.

or
^^

.. code-block:: none

 or operand1 $operand2
 or operand1 0xF0

Bitwise or variable or constant operand2 value with variable operand1
value or bitwise or value 0xF0 with variable operand1 value. The
resulting value of the bitwise or is in variable operand1 value after
the operation.

xor
^^^

.. code-block:: none

 xor operand1 $operand2
 xor operand1 0xF0

Bitwise xor variable or constant operand2 value with variable operand1
value or bitwise xor value 0xF0 with variable operand1 value. The
resulting value of the bitwise xor is in variable operand1 value after
the operation.

shl
^^^

.. code-block:: none

 shl operand1 $operand2
 shl operand1 0xF0

Bitwise shift left variable or constant operand2 value with variable
operand1 value or bitwise shift left value 0xF0 with variable operand1
value. The resulting value of the bitwise shift left is in variable
operand1 value after the operation.

shr
^^^

.. code-block:: none

 shr operand1 $operand2
 shr operand1 0xF0

Bitwise shift right variable or constant operand2 value with variable
operand1 value or bitwise shift right value 0xF0 with variable operand1
value. The resulting value of the bitwise shift right is in variable
operand1 value after the operation.

inv
^^^

.. code-block:: none

 inv operand1

Bitwise invert variable operand1 value. The resulting value of the
bitwise invert is in variable operand1 value after the operation.

ld
^^

.. code-block:: none

 ld operand1

Calculate logarithmus dualis of variable operand1 value. The resulting
value is in variable operand1 value after the operation. The function
returns the number of the utmost set bit, e.g., 4 for the input 16. It
returns 0 for the input 0 too since this is the best approximation in a
natural number range. The user should handle this discontinuity if
another result or an error is expected.

Subroutines, Branches, and Loops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

proc and end proc
^^^^^^^^^^^^^^^^^

.. code-block:: none

 aproc:
 proc
     --...
     -- subroutine code
     --...
 end proc

Code of a subroutine is placed between a ``proc`` and ``end proc`` instruction.
The subroutine name is a label placed on the line before the ``proc``
instruction, e.g., aproc. The label ends with a colon as a label
indicator.

call
^^^^

.. code-block:: none

 call $aproc

Branches execution to the subroutine with the label aproc and continues
execution with the next line when it returns from the subroutine after
it has reached an ``end proc`` or ``return`` instruction there.

return
^^^^^^

.. code-block:: none

 return

Returns to calling code from a subroutine.

interrupt and end interrupt
^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: none

 aninterrupt:
 interrupt
     --...
     -- interrupt subroutine code
     --...
 end interrupt

Code of an interrupt subroutine is placed between an ``interrupt`` 
and ``end interrupt instruction``. The interrupt subroutine name is a label placed
on the line before the ``interrupt`` instruction, e.g., aninterrupt. The label
ends with a colon as a label indicator. The label must be given in the
tbsignal package by customization and attached to a signal triggering
the interrupt. If necessary, the handling of nested interrupts must be
resolved there too.

if, elsif, else, and end if
^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: none

 if $avar = $bvar
     -- ... some code
 elsif $avar 0xABC
     -- ... some code
 elsif 0x123} $bvar
     -- ... some code
 else
     -- ... some code
 end if

Possible comparison operators are:
``>= <= > < != =``.

Compares 2 variables, constants, or numeric values and branches
execution to the next line if resolving to true. Otherwise, it branches
to the next ``elsif`` or ``else`` or ``end if`` instruction. 
The ``if`` instructions can be nested.

loop
^^^^

.. code-block:: none

 loop $lvar
     -- ... some code
 end loop
 
 loop32
     -- ... some code
 end loop

Executes a loop of the code between the ``loop`` and end ``loop`` instruction.
The number of times the loop should be executed is given after the ``loop``
keyword. It can be a numeric value, a variable, or a constant. In case
of a variable, this number can be changed by code within the loop, e.g.,
to skip loops or end the loop earlier, due to the global nature of all
variables. No break or continue instructions are supported therefore.
The loop can be terminated by a ``return`` instruction too at any time,
which is a good practice.

abort
^^^^^

.. code-block:: none

 abort

Aborts the simulation with severity failure.

finish
^^^^^^

.. code-block:: none

 finish

Exits the simulation with severity note or error. The latter occurs only
if resume has been set to other values than 0, and there were verify
errors in verify instructions.

Array Access
~~~~~~~~~~~~

Array Set
^^^^^^^^^

.. code-block:: none

 array set barray $pvar $avar
 array set barray 3 $avar
 array set barray $pvar 5
 array set barray 3 4

Set the value of ``barray`` at position ``pvar``to the value of ``avar`` or
``5``.
Set the value of ``barray`` at position ``3``to the value of ``avar`` or
``4``.

Array Get
^^^^^^^^^

.. code-block:: none

 array get barray $pvar tvar
 array get barray 5  tvar

Get the value of ``barray`` at position ``pvar`` or ``5`` into ``tvar``.

Array Size
^^^^^^^^^^

.. code-block:: none

 array size barray tvar

Get the size of an array.

Array Pointer Copy
^^^^^^^^^^^^^^^^^^

.. code-block:: none

 array pointer tarray sarray

Copy an array pointer; for example, ``tarray`` pointer is a copy of
``sarray`` pointer after the execution of the instruction. Used, for
instance, to hand over an array to a subroutine. Changes to the source
array happen in the target array too.

File Access
~~~~~~~~~~~

File Writeable
^^^^^^^^^^^^^^

.. code-block:: none

 file writeable afile rvar

Test if a file is writable. If the file is not present, it is created
without having content. The result is for STATUSOK 0, STATUSERROR 1,
STATUSNAMEERROR 2, STATUSMODEERROR 3 and may, in case of error, depend
on the operating system.

File Readable
^^^^^^^^^^^^^

.. code-block:: none

 file readable afile rvar

Test if a file is readable. The result is for STATUSOK 0, STATUSERROR 1,
STATUSNAMEERROR 2, STATUSMODEERROR 3 and may, in case of error, depend
on the operating system.

File Appendable
^^^^^^^^^^^^^^^

.. code-block:: none

 file appendable afile rvar

Test if a file is appendable. The result is for STATUSOK 0, STATUSERROR
1, STATUSNAMEERROR 2, STATUSMODEERROR 3 and may, in case of error,
depend on the operating system.

File Write
^^^^^^^^^^

.. code-block:: none

 file write afile alines

Write all lines of an ``alines`` object to a file. The file is
overwritten if it exists.

File Append
^^^^^^^^^^^

.. code-block:: none

 file write afile alines

Append all lines of an ``alines`` object to a file. The method will fail
if the file doesn’t exist.

File Read All
^^^^^^^^^^^^^

.. code-block:: none

 file read all afile alines

Read all lines of a file into an ``alines`` object.

File Read
^^^^^^^^^

.. code-block:: none

   file read afile alines $nvar
   file read afile alines 10

Read a number of lines from a file into an ``alines`` object. The first
read opens the file for read, following reads start at the line after
the last line which has been read by the previous read. Thus a file can
be read piecewise similar as it can be written piecewise by file append.
The piecewise read process of the file must be terminated by a file read
end instruction always. The number of concurrent file read processes is
limited to 4.

File Read End
^^^^^^^^^^^^^

.. code-block:: none

   file read end afile

End the piecewise read process of a file.

File Pointer Copy
^^^^^^^^^^^^^^^^^

.. code-block:: none

   file pointer tfile sfile

Copy a file pointer; for example, ``tfile`` pointer is a copy of
``sfile`` pointer after the execution of the instruction. Used, for
instance, to hand over a file to a subroutine. Changes to the source
file happen in the target file too.

Lines Access
~~~~~~~~~~~~

Lines Get
^^^^^^^^^

.. code-block:: none

 lines get array alines $pvar tarray rvar
 lines set array alines 9 tarray rvar

Get a line from a lines object at a given position and write its content
into an array. The line is expected to hold hex numbers (without 0x
prefix) separated by spaces (e.g., A123 BCF11 123 E333 would be 4 hex
numbers). The given array must be able to hold the number of found hex
numbers. It will not be filled completely if fewer than its size are
found. Numbers will be skipped if there are more hex numbers found than
the array can hold. The number of detected hex numbers is reported in a
result variable. Then the user can decide what action should follow a
mismatch.

Lines Set
^^^^^^^^^
.. code-block:: none

 lines set array alines $pvar sarray
 lines set array alines 9 sarray
 lines set message alines $pvar "Some message to be written to a file later"
 lines set message alines $pvar "Value1: {} Value2: {} to be written to a file later" $mvar1 $mvar2

Set a line at a given position of a lines object. The line currently at
this position is overwritten. The line can be derived from an array or a
message. The message string can contain {} placeholders which are filled
by values of variables given after the message string.

Lines Insert
^^^^^^^^^^^^

.. code-block:: none

 lines insert array alines $pvar sarray
 lines insert array alines 9 sarray
 lines insert message alines $pvar "Some message to be written to a file later"
 lines insert message alines $pvar "Value1: {} Value2: {} to be written to a file later" $mvar1 $mvar2

Insert a line at a given position of a lines object. The line currently
at this position is moved to the next position. The line can be derived
from an array or a message. The message string can contain {}
placeholders which are filled by values of variables given after the
message string.

Lines Append
^^^^^^^^^^^^

.. code-block:: none

 lines append array alines sarray
 lines append message alines "Some message to be written to a file later"
 lines append message alines "Value1: {} Value2: {} to be written to a file later" $mvar1 $mvar2

Append a line at the end of a lines object. The line can be derived from
an array or a message. The message string can contain {} placeholders
which are filled by values of variables given after the message string.

Lines Delete
^^^^^^^^^^^^

.. code-block:: none

 lines delete alines $pvar
 lines delete alines 3

Delete a line at a given position of a lines object. The next line is
moved to the given position if it exists.

Lines Size
^^^^^^^^^^

.. code-block:: none

 lines size alines rvar

Get the size of a lines object, which is the number of lines it contains
currently.

Lines Pointer Copy
^^^^^^^^^^^^^^^^^^

.. code-block:: none

 lines pointer tlines slines

Copy a lines pointer; for example, ``tlines`` pointer is a copy of
``slines``

Log
~~~

Log Message
^^^^^^^^^^^

.. code-block:: none

 log message $vvar "A message to the console"
 log message} $vvar "A message to the console{}{}" $mvar1 $mvar2

Print a message at a given verbosity level to the console. The message
string can contain {} placeholders which are filled by values of
variables given after the message string.

Log Lines
^^^^^^^^^

.. code-block:: none

 log lines} $vvar slines

Dump a lines object at a given verbosity level to the console.

Verbosity
^^^^^^^^^

.. code-block:: none

 verbosity $vvar
 verbosity 20

Usual practice is to use the following constants to set verbosity:

.. code-block:: none

 const FAILURE 0
 const WARNING 10
 const INFO 20

Sets the global verbosity for log messages. Log messages with a
verbosity level greater than the globally set verbosity are not printed
to the console. Of course, the global verbosity can be changed at any
point in the execution flow.

Wait
~~~~

.. code-block:: none

 wait $wvar
 wait 10000

Waits for the given number of nanoseconds.

Random Numbers
~~~~~~~~~~~~~~

Random
^^^^^^

.. code-block:: none

 random tvar $minvar $maxvar
 random tvar 0 10

Generates a random number greater or equal to the min value given and
less than the maximum number given.

Seed
^^^^

.. code-block:: none

 seed $svar
 seed 10

Set the internal start value for the random number generator.

Debug
~~~~~

Trace
^^^^^

.. code-block:: none

 trace $tvar
 trace 0b111

The trace instruction enables or disables the output of trace
information when it is set at some point during the SimStm code
execution. Thus, e.g., the flow through complex if, elsif … trees can be
shown.

-  Setting the bit 0 in the given value prints the lines of code with
   some additional information.
-  Setting the bit 1 dumps all(!) objects before a line is executed.
-  Setting the bit 2 dumps all file names currently in use.

Marker
^^^^^^

.. code-block:: none

 marker $nvar $mvar
 marker 0xF 0b1

The ``tb_simstm`` entity has an output signal marker which is a
``std_logic_vector(15 downto 0)``. Thus there are 16 markers which can
be set ``0b1`` or ``0b0``. This should be used to mark occurrences
during the execution of the SimStm code so they can be found easily in
the waveform display. Beneath this, the ``Executing_Line`` and
``Executing_File`` ``tb_simstm`` intern variables are always present and
show the currently executed line of code.

Signal and Bus Access
~~~~~~~~~~~~~~~~~~~~~

Signal Write
^^^^^^^^^^^^

.. code-block:: none

 signal write asignal $svar
 signal write asignal 0b11

Write variable, constant, or numeric value to a signal.

Signal Read
^^^^^^^^^^^

.. code-block:: none

 signal read asignal tvar

Read the value of a signal into a variable.

Signal Verify
^^^^^^^^^^^^^

.. code-block:: none

 signal verify asignal tvar $evar $mvar
 signal verify asignal tvar 0x01 0x0F

Read the value of a signal into a variable and compare it to an expected
value with a given mask. The expected value and mask can be variables,
constants, or numeric values. On mismatch, the simulation stops with
severity failure if the global resume is set to 0.

Bus Write
^^^^^^^^^

.. code-block:: none

 bus write abus $width $address $wvar
 bus write abus 32 0x0004 0x12345678

Write a variable, constant, or numeric value to a bus.

Bus Read
^^^^^^^^

.. code-block:: none

 bus read abus $width $address tvar

Read the value of a bus into a variable.

Bus Verify
^^^^^^^^^^

.. code-block:: none

 bus verify abus $width $address tvar $evar $mvar
 bus verify abus $width $address tva r0x01 0x0F

Read the value of a bus into a variable and compare it to an expected
value with a given mask. The expected value and mask can be variables,
constants, or numeric values. On mismatch, the simulation stops with
severity failure if the global resume is set to 0; otherwise, it
continues and reports an error.

Bus Timeout
^^^^^^^^^^^

.. code-block:: none

 bus timeout abus $svar
 bus timeout abus 1000*

Sets the timeout in nanoseconds to wait for a bus access to end. On
violation, the simulation stops with severity failure always.

Resume
^^^^^^

.. code-block:: none

 resume $EXIT_ON_VERIFY_ERROR
 resume 0

| Usual practice is to use the following constants to set verbosity:
| ``const`` ``RESUME_ON_VERIFY_ERROR 1``
| ``const`` ``EXIT_ON_VERIFY_ERROR 0``

Sets the global resume behavior for verify instructions. On a verify
mismatch, the simulation stops with severity failure if the global
resume is set to 0; otherwise, it continues and reports an error.

Examples
--------

Hello World
~~~~~~~~~~~

.. code-block:: none

 const YEAR 2023
 var month 11
 var day 22

 testMain:
 proc`
     loop 3
       log message 0 "Hello World {:d}-{:d}-{:d}" $YEAR $month $day
     end loop`
     finish
 end proc

This example is a unit test too and can be found in the repository
folder `test/others/hello_world <./test/others/hello_world>`__.

An demonstration of all commands is in the file
`command_list.stm <./command_list.stm>`__ in the repository root
folder..

Unit Tests
~~~~~~~~~~

The test folder contains unittest for all commands. Thus all commands
are verified for each release by regression tests.

SPI Controller
~~~~~~~~~~~~~~

A complex real-world example is found in the eccelerators spi_controller
repository on GitHub, see
https://github.com/eccelerators/spi-controller.
